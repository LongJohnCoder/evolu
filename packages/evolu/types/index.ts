import { IO } from 'fp-ts/lib/IO';
import { Option } from 'fp-ts/lib/Option';
import { Task } from 'fp-ts/lib/Task';
import { Newtype } from 'newtype-ts';
import { ReactDOM, ReactNode, Reducer } from 'react';
import { $Values } from 'utility-types';
import {
  DOMNode,
  DOMRange,
  DOMSelection,
  DOMNodeOffset,
  ExistingDOMSelection,
} from './dom';

/**
 * Editor text is a string. Like in React.
 */
export type Text = string;

/**
 * Editor unique string ID generated by nanoid. ID is required for
 * meta-data, React keys, and CRDT.
 */
export interface ElementID
  extends Newtype<{ readonly ElementID: unique symbol }, string> {}

/**
 * Editor element. The base for all other editor elements.
 */
export interface Element {
  readonly id: ElementID;
  readonly children: Node[];
}

export type Node = Element | Text;

// TODO: Consider newtype.
export type PathIndex = number;

/**
 * Path to a place in Element. It can point to Element, Text, Text char, or nothing.
 */
export type Path = PathIndex[];

/**
 * Non empty Path.
 */
export interface NonEmptyPath extends Path {
  0: PathIndex;
}

/**
 * Non empty Path with offset.
 */
export interface NonEmptyPathWithOffset extends Path {
  0: PathIndex;
  1: PathIndex;
}

/**
 * Editor selection. It's like DOM Selection, but with Path for the anchor and the focus.
 * https://developer.mozilla.org/en-US/docs/Web/API/Selection
 */
export interface Selection {
  readonly anchor: NonEmptyPath;
  readonly focus: NonEmptyPath;
}

/**
 * Editor value.
 */
export interface Value {
  readonly element: Element;
  readonly hasFocus: boolean;
  readonly selection: Option<Selection>;
}

export type SetTextArg = {
  text: Text;
  path: NonEmptyPath;
  selection: Selection;
};

export type EditorAction =
  | { type: 'focus' }
  | { type: 'blur' }
  | { type: 'selectionChange'; selection: Selection }
  | { type: 'setText'; arg: SetTextArg }
  | { type: 'deleteContent'; selection: Selection };

export type EditorReducer = Reducer<Value, EditorAction>;

/**
 * Editor range. It's like DOM Range, but with editor path for the start and the end.
 * Range should be an implementation detail when an operation needs the direction.
 * https://developer.mozilla.org/en-US/docs/Web/API/Range
 */
export interface Range {
  readonly start: NonEmptyPath;
  readonly end: NonEmptyPath;
}

export type GetDOMNodeByPath = (path: Path) => IO<Option<DOMNode>>;
export type GetPathByDOMNode = (node: DOMNode) => IO<Option<Path>>;

export type SetDOMNodePathRef = (node: DOMNode | null) => void;

export type SetDOMNodePath = (
  operation: 'add' | 'remove',
  node: DOMNode,
  path: Path,
) => void;

export type RenderElement = (
  element: Element,
  children: ReactNode,
  ref: SetDOMNodePathRef,
) => ReactNode;

interface ReactElementFactory<T, P> extends Element {
  readonly tag: T;
  readonly props?: P;
  readonly children: (ReactElement | Text)[];
}

/**
 * Editor React-like element. It has tag and props.
 */
export type ReactElement = $Values<
  {
    [T in keyof ReactDOM]: ReactElementFactory<
      T,
      ReturnType<ReactDOM[T]>['props']
    >;
  }
>;

export type EditorElementAttrs = Pick<
  React.HTMLAttributes<HTMLDivElement>,
  | 'accessKey'
  | 'autoCorrect'
  | 'className'
  | 'id'
  | 'role'
  | 'spellCheck'
  | 'style'
  | 'tabIndex'
>;

export type EditorProps = EditorElementAttrs & {
  readonly value: Value;
  readonly onChange: (value: Value) => void;
  readonly renderElement?: RenderElement;
};

/**
 * Editor side effects. There are two abstractions meant for side effects:
 * IO (synchronous) and Task (asynchronous). Both of them have the -Either
 * "version" for computations that may fail.
 */
export interface EditorIO {
  readonly afterTyping: Task<void>;
  readonly createDOMRange: IO<Option<DOMRange>>;
  readonly createInfo: (selection: Selection) => Info; // TODO: IO
  readonly dispatch: (action: EditorAction) => IO<void>;
  readonly DOMRangeToSelection: (range: DOMRange) => IO<Option<Selection>>;
  readonly ensureDOMSelectionIsActual: IO<void>;
  readonly focus: IO<void>;
  readonly getDocument: IO<Option<Document>>;
  readonly getDOMNodeByPath: GetDOMNodeByPath;
  readonly getDOMSelection: IO<Option<DOMSelection>>;
  readonly getElement: IO<Option<HTMLDivElement>>;
  readonly getExistingDOMSelection: IO<Option<ExistingDOMSelection>>;
  readonly getPathByDOMNode: GetPathByDOMNode;
  readonly getSelectionFromDOM: IO<Option<Selection>>;
  readonly getValue: IO<Value>;
  readonly isTyping: IO<boolean>;
  readonly pathToNodeOffset: (path: NonEmptyPath) => IO<Option<DOMNodeOffset>>;
  readonly setDOMSelection: (selection: Selection) => IO<void>;
}

// TODO: Fragment, probably Child[].

export interface NodeInfo {
  readonly node: Node;
  readonly path: NonEmptyPath;
  // readonly text: string;
  // readonly parents: NonEmptyArray<Element>;
  // readonly parentBlocks: NonEmptyArray<Element>;
  // readonly previousSibling: Option<Child>;
  // readonly nextSibling: Option<Child>;
  // readonly textOffset: Option<number>;
  // readonly allChildrenCount: number;
}

/**
 * Info is materialized selection. It provides useful computations for
 * toolbars and operations.
 */
export interface Info {
  // selection: Selection;
  // range: Range;
  nodes: NodeInfo[];
  // text: Node;
  // range position
}
