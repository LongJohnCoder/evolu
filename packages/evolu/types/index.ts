import { ReactNode, ReactDOM, Reducer as ReactReducer } from 'react';
import { Newtype } from 'newtype-ts';
import { Option } from 'fp-ts/lib/Option';
import { $Values } from 'utility-types';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { empty } from 'fp-ts/lib/Array';
import { DOMNode } from './dom';

/**
 * Editor unique string ID generated by nanoid. ID is required for
 * meta-data, React keys, and CRDT.
 */
export interface NodeID
  extends Newtype<{ readonly NodeID: unique symbol }, string> {}

/**
 * Editor node.
 */
export interface Node {
  readonly id: NodeID;
}

/**
 * Editor text.
 */
export interface Text extends Node {
  readonly text: string;
}

/**
 * Editor element. The base for all other editor elements.
 */
export interface Element extends Node {
  readonly children: (Child)[];
}

/**
 * Editor child. Only editor element or text.
 */
export type Child = Element | Text;

/**
 * Editor path is non empty array of path indexes which can be resolved
 * to element or text or text with offset or to nothing.
 */
// It's not readonly array, because https://github.com/gcanti/fp-ts/issues/987.
export type Path = NonEmptyArray<number>;

export type PathOrEmpty = Path | typeof empty;

/**
 * Editor selection. It's like DOM Selection, but with Path for the anchor and the focus.
 * https://developer.mozilla.org/en-US/docs/Web/API/Selection
 */
export interface Selection {
  readonly anchor: Path;
  readonly focus: Path;
}

/**
 * Editor value.
 */
export interface Value {
  readonly element: Element;
  readonly hasFocus: boolean;
  readonly selection: Option<Selection>;
}

/**
 * Editor action.
 */
export type Action =
  | { type: 'focus' }
  | { type: 'blur' }
  | { type: 'selectionChange'; selection: Selection }
  | { type: 'insertText'; text: string; selection: Selection }
  | { type: 'deleteText'; text: string; selection: Selection }
  | { type: 'insertReplacementText'; text: string }
  | { type: 'deleteContent'; selection: Selection };

/**
 * Editor reducer.
 */
export type Reducer = ReactReducer<Value, Action>;

/**
 * Editor range. It's like DOM Range, but with editor path for the start and the end.
 * Range should be an implementation detail when an operation needs the direction.
 * https://developer.mozilla.org/en-US/docs/Web/API/Range
 */
export interface Range {
  readonly start: Path;
  readonly end: Path;
}

export type DOMNodeOffset = [DOMNode, number];

export type GetDOMNodeByPath = (path: PathOrEmpty) => Option<DOMNode>;

export type GetPathByDOMNode = (domNode: DOMNode) => Option<PathOrEmpty>;

export type SetDOMNodePathRef = (node: DOMNode | null) => void;

export type SetDOMNodePath = (
  operation: 'add' | 'remove',
  node: DOMNode,
  path: PathOrEmpty,
) => void;

export type RenderElement = (
  element: Element,
  children: ReactNode,
  ref: SetDOMNodePathRef,
) => ReactNode;

export type AfterTyping = (callback: () => void) => void;

interface ReactElementFactory<T, P> extends Element {
  readonly tag: T;
  readonly props?: P;
  readonly children: (ReactElement | Text)[];
}

/**
 * Editor React-like element. It has tag and props.
 */
export type ReactElement = $Values<
  {
    [T in keyof ReactDOM]: ReactElementFactory<
      T,
      ReturnType<ReactDOM[T]>['props']
    >;
  }
>;

type ReactDivAtttributesUsefulForEditor = Pick<
  React.HTMLAttributes<HTMLDivElement>,
  | 'accessKey'
  | 'autoCorrect'
  | 'className'
  | 'id'
  | 'role'
  | 'spellCheck'
  | 'style'
  | 'tabIndex'
>;

export interface EditorProps extends ReactDivAtttributesUsefulForEditor {
  readonly value: Value;
  readonly onChange: (value: Value) => void;
  readonly renderElement?: RenderElement;
  readonly reducer?: Reducer;
}

export interface EditorRef {
  readonly focus: () => void;
  // TODO: findDOMNodeByPath, materizalizeSelection
}

// TODO: Fragment, probably Child[].

export interface MaterializedSelectionChild {
  readonly child: Child;
  readonly path: Path;
  readonly parents: NonEmptyArray<Element>;
  readonly parentBlocks: NonEmptyArray<Element>;
  readonly previousSibling: Option<Child>;
  readonly nextSibling: Option<Child>;
  readonly textOffset: Option<number>;
  readonly allChildrenCount: number;
}

/**
 * MaterializedSelection is Selection with aditional useful computations.
 * Some of them are depending on DOM state. Editor model knows nothing about
 * block/inline styles because it depends on CSS. That's why MaterializedSelection
 * is not part of Value. It's side effect.
 */
export interface MaterializedSelection extends Selection {
  children: MaterializedSelectionChild[];
  text: string;
}
